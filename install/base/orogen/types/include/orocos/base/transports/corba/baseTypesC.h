// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __baseTypes_hh__
#define __baseTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_baseTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_baseTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_baseTypes
#endif



#ifndef __stdTypes_hh_EXTERNAL_GUARD__
#define __stdTypes_hh_EXTERNAL_GUARD__
#include <std/transports/corba/stdTypesC.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE orogen

_CORBA_MODULE_BEG

  _CORBA_MODULE base

  _CORBA_MODULE_BEG

    _CORBA_MODULE JointState

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        enum MODE { ACCELERATION, EFFORT, POSITION, RAW, SPEED, UNSET /*, __max_MODE=0xffffffff */ };
        typedef MODE& MODE_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MODE;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Time

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        enum Resolution { Microseconds, Milliseconds, Seconds /*, __max_Resolution=0xffffffff */ };
        typedef Resolution& Resolution_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Resolution;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE geometry

    _CORBA_MODULE_BEG

      _CORBA_MODULE SplineBase

      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba

        _CORBA_MODULE_BEG

          enum CoordinateType { DERIVATIVE_TO_NEXT, DERIVATIVE_TO_PRIOR, KNUCKLE_POINT, ORDINARY_POINT, SECOND_DERIVATIVE_TO_NEXT, SECOND_DERIVATIVE_TO_PRIOR, TANGENT_POINT_FOR_NEXT, TANGENT_POINT_FOR_PRIOR /*, __max_CoordinateType=0xffffffff */ };
          typedef CoordinateType& CoordinateType_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CoordinateType;

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples

    _CORBA_MODULE_BEG

      _CORBA_MODULE DepthMap

      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba

        _CORBA_MODULE_BEG

          enum DEPTH_MEASUREMENT_STATE { MEASUREMENT_ERROR, TOO_FAR, TOO_NEAR, VALID_MEASUREMENT /*, __max_DEPTH_MEASUREMENT_STATE=0xffffffff */ };
          typedef DEPTH_MEASUREMENT_STATE& DEPTH_MEASUREMENT_STATE_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DEPTH_MEASUREMENT_STATE;

          enum PROJECTION_TYPE { PLANAR, POLAR /*, __max_PROJECTION_TYPE=0xffffffff */ };
          typedef PROJECTION_TYPE& PROJECTION_TYPE_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PROJECTION_TYPE;

          enum UNIT_AXIS { UNIT_X, UNIT_Y, UNIT_Z /*, __max_UNIT_AXIS=0xffffffff */ };
          typedef UNIT_AXIS& UNIT_AXIS_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UNIT_AXIS;

        _CORBA_MODULE_END

      _CORBA_MODULE_END

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        enum LASER_RANGE_ERRORS { END_LASER_RANGE_ERRORS, MAX_RANGE_ERROR, MEASUREMENT_ERROR, OTHER_RANGE_ERRORS, TOO_FAR, TOO_NEAR /*, __max_LASER_RANGE_ERRORS=0xffffffff */ };
        typedef LASER_RANGE_ERRORS& LASER_RANGE_ERRORS_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LASER_RANGE_ERRORS;

      _CORBA_MODULE_END

      _CORBA_MODULE frame

      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba

        _CORBA_MODULE_BEG

          enum frame_mode_t { COMPRESSED_MODES, MODE_BAYER, MODE_BAYER_BGGR, MODE_BAYER_GBRG, MODE_BAYER_GRBG, MODE_BAYER_RGGB, MODE_BGR, MODE_GRAYSCALE, MODE_JPEG, MODE_PJPG, MODE_PNG, MODE_RGB, MODE_RGB32, MODE_UNDEFINED, MODE_UYVY, RAW_MODES /*, __max_frame_mode_t=0xffffffff */ };
          typedef frame_mode_t& frame_mode_t_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_frame_mode_t;

          enum frame_status_t { STATUS_EMPTY, STATUS_INVALID, STATUS_VALID /*, __max_frame_status_t=0xffffffff */ };
          typedef frame_status_t& frame_status_t_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_frame_status_t;

          struct frame_size_t {
            typedef _CORBA_ConstrType_Fix_Var<frame_size_t> _var_type;

            
            ::CORBA::UShort width;

            ::CORBA::UShort height;

          

            void operator>>= (cdrStream &) const;
            void operator<<= (cdrStream &);
          };

          typedef frame_size_t::_var_type frame_size_t_var;

          typedef frame_size_t& frame_size_t_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_frame_size_t;

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      struct Angle {
        typedef _CORBA_ConstrType_Fix_Var<Angle> _var_type;

        
        ::CORBA::Double rad;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Angle::_var_type Angle_var;

      typedef Angle& Angle_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Angle;

      struct JointState {
        typedef _CORBA_ConstrType_Fix_Var<JointState> _var_type;

        
        ::CORBA::Double position;

        ::CORBA::Float speed;

        ::CORBA::Float effort;

        ::CORBA::Float raw;

        ::CORBA::Float acceleration;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef JointState::_var_type JointState_var;

      typedef JointState& JointState_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_JointState;

      struct PoseUpdateThreshold {
        typedef _CORBA_ConstrType_Fix_Var<PoseUpdateThreshold> _var_type;

        
        ::CORBA::Double distance;

        ::CORBA::Double angle;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef PoseUpdateThreshold::_var_type PoseUpdateThreshold_var;

      typedef PoseUpdateThreshold& PoseUpdateThreshold_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PoseUpdateThreshold;

      struct Pressure {
        typedef _CORBA_ConstrType_Fix_Var<Pressure> _var_type;

        
        ::CORBA::Float pascal;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Pressure::_var_type Pressure_var;

      typedef Pressure& Pressure_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Pressure;

      struct Temperature {
        typedef _CORBA_ConstrType_Fix_Var<Temperature> _var_type;

        
        ::CORBA::Double kelvin;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Temperature::_var_type Temperature_var;

      typedef Temperature& Temperature_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Temperature;

      struct Time {
        typedef _CORBA_ConstrType_Fix_Var<Time> _var_type;

        
        ::CORBA::LongLong microseconds;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Time::_var_type Time_var;

      typedef Time& Time_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Time;

      struct JointLimitRange {
        typedef _CORBA_ConstrType_Fix_Var<JointLimitRange> _var_type;

        
        JointState min;

        JointState max;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef JointLimitRange::_var_type JointLimitRange_var;

      typedef JointLimitRange& JointLimitRange_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_JointLimitRange;

      struct TimeStamped__base_commands_Motion2D_ {
        typedef _CORBA_ConstrType_Fix_Var<TimeStamped__base_commands_Motion2D_> _var_type;

        
        ::CORBA::Double translation;

        ::CORBA::Double rotation;

        Angle heading;

        Corba::Time time;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef TimeStamped__base_commands_Motion2D_::_var_type TimeStamped__base_commands_Motion2D__var;

      typedef TimeStamped__base_commands_Motion2D_& TimeStamped__base_commands_Motion2D__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TimeStamped__base_commands_Motion2D_;

    _CORBA_MODULE_END

    _CORBA_MODULE commands

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        struct Motion2D {
          typedef _CORBA_ConstrType_Fix_Var<Motion2D> _var_type;

          
          ::CORBA::Double translation;

          ::CORBA::Double rotation;

          base::Corba::Angle heading;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Motion2D::_var_type Motion2D_var;

        typedef Motion2D& Motion2D_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Motion2D;

        struct Speed6D {
          typedef _CORBA_ConstrType_Fix_Var<Speed6D> _var_type;

          
          ::CORBA::Double surge;

          ::CORBA::Double sway;

          ::CORBA::Double heave;

          ::CORBA::Double roll;

          ::CORBA::Double pitch;

          ::CORBA::Double yaw;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Speed6D::_var_type Speed6D_var;

        typedef Speed6D& Speed6D_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Speed6D;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        struct Motion2D {
          typedef _CORBA_ConstrType_Fix_Var<Motion2D> _var_type;

          
          ::CORBA::Double translation;

          ::CORBA::Double rotation;

          base::Corba::Angle heading;

          base::Corba::Time time;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Motion2D::_var_type Motion2D_var;

        typedef Motion2D& Motion2D_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Motion2D;

        struct Pressure {
          typedef _CORBA_ConstrType_Fix_Var<Pressure> _var_type;

          
          ::CORBA::Float pascal;

          base::Corba::Time time;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Pressure::_var_type Pressure_var;

        typedef Pressure& Pressure_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Pressure;

        struct Temperature {
          typedef _CORBA_ConstrType_Fix_Var<Temperature> _var_type;

          
          ::CORBA::Double kelvin;

          base::Corba::Time time;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Temperature::_var_type Temperature_var;

        typedef Temperature& Temperature_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Temperature;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_Angle_;

      class vector__base_Angle__var;

      class vector__base_Angle_ : public _CORBA_Unbounded_Sequence< Angle >  {
      public:
        typedef vector__base_Angle__var _var_type;
        inline vector__base_Angle_() {}
        inline vector__base_Angle_(const vector__base_Angle_& _s)
          : _CORBA_Unbounded_Sequence< Angle > (_s) {}

        inline vector__base_Angle_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Angle > (_max) {}
        inline vector__base_Angle_(_CORBA_ULong _max, _CORBA_ULong _len, Angle* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Angle > (_max, _len, _val, _rel) {}

      

        inline vector__base_Angle_& operator = (const vector__base_Angle_& _s) {
          _CORBA_Unbounded_Sequence< Angle > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_Angle__out;

      class vector__base_Angle__var {
      public:
        inline vector__base_Angle__var() : _pd_seq(0) {}
        inline vector__base_Angle__var(vector__base_Angle_* _s) : _pd_seq(_s) {}
        inline vector__base_Angle__var(const vector__base_Angle__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_Angle_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_Angle__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_Angle__var& operator = (vector__base_Angle_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_Angle__var& operator = (const vector__base_Angle__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_Angle_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline Angle& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_Angle_* operator -> () { return _pd_seq; }
        inline const vector__base_Angle_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_Angle_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_Angle_& () const { return *_pd_seq; }
        inline operator vector__base_Angle_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_Angle_& in() const { return *_pd_seq; }
        inline vector__base_Angle_&       inout()    { return *_pd_seq; }
        inline vector__base_Angle_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_Angle_* _retn() { vector__base_Angle_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_Angle__out;
        
      private:
        vector__base_Angle_* _pd_seq;
      };

      class vector__base_Angle__out {
      public:
        inline vector__base_Angle__out(vector__base_Angle_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_Angle__out(vector__base_Angle__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_Angle_*) 0; }
        inline vector__base_Angle__out(const vector__base_Angle__out& _s) : _data(_s._data) {}
        inline vector__base_Angle__out& operator = (const vector__base_Angle__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_Angle__out& operator = (vector__base_Angle_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_Angle_*&()  { return _data; }
        inline vector__base_Angle_*& ptr()       { return _data; }
        inline vector__base_Angle_* operator->() { return _data; }

        inline Angle& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_Angle_*& _data;

      private:
        vector__base_Angle__out();
        vector__base_Angle__out& operator=(const vector__base_Angle__var&);
      };

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_JointLimitRange_;

      class vector__base_JointLimitRange__var;

      class vector__base_JointLimitRange_ : public _CORBA_Unbounded_Sequence< JointLimitRange >  {
      public:
        typedef vector__base_JointLimitRange__var _var_type;
        inline vector__base_JointLimitRange_() {}
        inline vector__base_JointLimitRange_(const vector__base_JointLimitRange_& _s)
          : _CORBA_Unbounded_Sequence< JointLimitRange > (_s) {}

        inline vector__base_JointLimitRange_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< JointLimitRange > (_max) {}
        inline vector__base_JointLimitRange_(_CORBA_ULong _max, _CORBA_ULong _len, JointLimitRange* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< JointLimitRange > (_max, _len, _val, _rel) {}

      

        inline vector__base_JointLimitRange_& operator = (const vector__base_JointLimitRange_& _s) {
          _CORBA_Unbounded_Sequence< JointLimitRange > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_JointLimitRange__out;

      class vector__base_JointLimitRange__var {
      public:
        inline vector__base_JointLimitRange__var() : _pd_seq(0) {}
        inline vector__base_JointLimitRange__var(vector__base_JointLimitRange_* _s) : _pd_seq(_s) {}
        inline vector__base_JointLimitRange__var(const vector__base_JointLimitRange__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_JointLimitRange_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_JointLimitRange__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_JointLimitRange__var& operator = (vector__base_JointLimitRange_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_JointLimitRange__var& operator = (const vector__base_JointLimitRange__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_JointLimitRange_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline JointLimitRange& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_JointLimitRange_* operator -> () { return _pd_seq; }
        inline const vector__base_JointLimitRange_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_JointLimitRange_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_JointLimitRange_& () const { return *_pd_seq; }
        inline operator vector__base_JointLimitRange_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_JointLimitRange_& in() const { return *_pd_seq; }
        inline vector__base_JointLimitRange_&       inout()    { return *_pd_seq; }
        inline vector__base_JointLimitRange_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_JointLimitRange_* _retn() { vector__base_JointLimitRange_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_JointLimitRange__out;
        
      private:
        vector__base_JointLimitRange_* _pd_seq;
      };

      class vector__base_JointLimitRange__out {
      public:
        inline vector__base_JointLimitRange__out(vector__base_JointLimitRange_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_JointLimitRange__out(vector__base_JointLimitRange__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_JointLimitRange_*) 0; }
        inline vector__base_JointLimitRange__out(const vector__base_JointLimitRange__out& _s) : _data(_s._data) {}
        inline vector__base_JointLimitRange__out& operator = (const vector__base_JointLimitRange__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_JointLimitRange__out& operator = (vector__base_JointLimitRange_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_JointLimitRange_*&()  { return _data; }
        inline vector__base_JointLimitRange_*& ptr()       { return _data; }
        inline vector__base_JointLimitRange_* operator->() { return _data; }

        inline JointLimitRange& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_JointLimitRange_*& _data;

      private:
        vector__base_JointLimitRange__out();
        vector__base_JointLimitRange__out& operator=(const vector__base_JointLimitRange__var&);
      };

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_JointState_;

      class vector__base_JointState__var;

      class vector__base_JointState_ : public _CORBA_Unbounded_Sequence< JointState >  {
      public:
        typedef vector__base_JointState__var _var_type;
        inline vector__base_JointState_() {}
        inline vector__base_JointState_(const vector__base_JointState_& _s)
          : _CORBA_Unbounded_Sequence< JointState > (_s) {}

        inline vector__base_JointState_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< JointState > (_max) {}
        inline vector__base_JointState_(_CORBA_ULong _max, _CORBA_ULong _len, JointState* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< JointState > (_max, _len, _val, _rel) {}

      

        inline vector__base_JointState_& operator = (const vector__base_JointState_& _s) {
          _CORBA_Unbounded_Sequence< JointState > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_JointState__out;

      class vector__base_JointState__var {
      public:
        inline vector__base_JointState__var() : _pd_seq(0) {}
        inline vector__base_JointState__var(vector__base_JointState_* _s) : _pd_seq(_s) {}
        inline vector__base_JointState__var(const vector__base_JointState__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_JointState_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_JointState__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_JointState__var& operator = (vector__base_JointState_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_JointState__var& operator = (const vector__base_JointState__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_JointState_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline JointState& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_JointState_* operator -> () { return _pd_seq; }
        inline const vector__base_JointState_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_JointState_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_JointState_& () const { return *_pd_seq; }
        inline operator vector__base_JointState_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_JointState_& in() const { return *_pd_seq; }
        inline vector__base_JointState_&       inout()    { return *_pd_seq; }
        inline vector__base_JointState_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_JointState_* _retn() { vector__base_JointState_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_JointState__out;
        
      private:
        vector__base_JointState_* _pd_seq;
      };

      class vector__base_JointState__out {
      public:
        inline vector__base_JointState__out(vector__base_JointState_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_JointState__out(vector__base_JointState__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_JointState_*) 0; }
        inline vector__base_JointState__out(const vector__base_JointState__out& _s) : _data(_s._data) {}
        inline vector__base_JointState__out& operator = (const vector__base_JointState__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_JointState__out& operator = (vector__base_JointState_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_JointState_*&()  { return _data; }
        inline vector__base_JointState_*& ptr()       { return _data; }
        inline vector__base_JointState_* operator->() { return _data; }

        inline JointState& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_JointState_*& _data;

      private:
        vector__base_JointState__out();
        vector__base_JointState__out& operator=(const vector__base_JointState__var&);
      };

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_Time_;

      class vector__base_Time__var;

      class vector__base_Time_ : public _CORBA_Unbounded_Sequence< Time >  {
      public:
        typedef vector__base_Time__var _var_type;
        inline vector__base_Time_() {}
        inline vector__base_Time_(const vector__base_Time_& _s)
          : _CORBA_Unbounded_Sequence< Time > (_s) {}

        inline vector__base_Time_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Time > (_max) {}
        inline vector__base_Time_(_CORBA_ULong _max, _CORBA_ULong _len, Time* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Time > (_max, _len, _val, _rel) {}

      

        inline vector__base_Time_& operator = (const vector__base_Time_& _s) {
          _CORBA_Unbounded_Sequence< Time > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_Time__out;

      class vector__base_Time__var {
      public:
        inline vector__base_Time__var() : _pd_seq(0) {}
        inline vector__base_Time__var(vector__base_Time_* _s) : _pd_seq(_s) {}
        inline vector__base_Time__var(const vector__base_Time__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_Time_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_Time__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_Time__var& operator = (vector__base_Time_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_Time__var& operator = (const vector__base_Time__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_Time_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline Time& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_Time_* operator -> () { return _pd_seq; }
        inline const vector__base_Time_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_Time_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_Time_& () const { return *_pd_seq; }
        inline operator vector__base_Time_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_Time_& in() const { return *_pd_seq; }
        inline vector__base_Time_&       inout()    { return *_pd_seq; }
        inline vector__base_Time_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_Time_* _retn() { vector__base_Time_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_Time__out;
        
      private:
        vector__base_Time_* _pd_seq;
      };

      class vector__base_Time__out {
      public:
        inline vector__base_Time__out(vector__base_Time_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_Time__out(vector__base_Time__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_Time_*) 0; }
        inline vector__base_Time__out(const vector__base_Time__out& _s) : _data(_s._data) {}
        inline vector__base_Time__out& operator = (const vector__base_Time__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_Time__out& operator = (vector__base_Time_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_Time_*&()  { return _data; }
        inline vector__base_Time_*& ptr()       { return _data; }
        inline vector__base_Time_* operator->() { return _data; }

        inline Time& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_Time_*& _data;

      private:
        vector__base_Time__out();
        vector__base_Time__out& operator=(const vector__base_Time__var&);
      };

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE Corba

  _CORBA_MODULE_BEG

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__float_;

    class vector__float__var;

    class vector__float_ : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  {
    public:
      typedef vector__float__var _var_type;
      inline vector__float_() {}
      inline vector__float_(const vector__float_& _s)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_s) {}

      inline vector__float_(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max) {}
      inline vector__float_(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Float* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline vector__float_& operator = (const vector__float_& _s) {
        _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class vector__float__out;

    class vector__float__var {
    public:
      inline vector__float__var() : _pd_seq(0) {}
      inline vector__float__var(vector__float_* _s) : _pd_seq(_s) {}
      inline vector__float__var(const vector__float__var& _s) {
        if (_s._pd_seq)  _pd_seq = new vector__float_(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~vector__float__var() { if (_pd_seq)  delete _pd_seq; }
        
      inline vector__float__var& operator = (vector__float_* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline vector__float__var& operator = (const vector__float__var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new vector__float_;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ::CORBA::Float& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline vector__float_* operator -> () { return _pd_seq; }
      inline const vector__float_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator vector__float_& () const { return *_pd_seq; }
#else
      inline operator const vector__float_& () const { return *_pd_seq; }
      inline operator vector__float_& () { return *_pd_seq; }
#endif
        
      inline const vector__float_& in() const { return *_pd_seq; }
      inline vector__float_&       inout()    { return *_pd_seq; }
      inline vector__float_*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline vector__float_* _retn() { vector__float_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class vector__float__out;
      
    private:
      vector__float_* _pd_seq;
    };

    class vector__float__out {
    public:
      inline vector__float__out(vector__float_*& _s) : _data(_s) { _data = 0; }
      inline vector__float__out(vector__float__var& _s)
        : _data(_s._pd_seq) { _s = (vector__float_*) 0; }
      inline vector__float__out(const vector__float__out& _s) : _data(_s._data) {}
      inline vector__float__out& operator = (const vector__float__out& _s) {
        _data = _s._data;
        return *this;
      }
      inline vector__float__out& operator = (vector__float_* _s) {
        _data = _s;
        return *this;
      }
      inline operator vector__float_*&()  { return _data; }
      inline vector__float_*& ptr()       { return _data; }
      inline vector__float_* operator->() { return _data; }

      inline ::CORBA::Float& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      vector__float_*& _data;

    private:
      vector__float__out();
      vector__float__out& operator=(const vector__float__var&);
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__uint32_t_;

    class vector__uint32_t__var;

    class vector__uint32_t_ : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 >  {
    public:
      typedef vector__uint32_t__var _var_type;
      inline vector__uint32_t_() {}
      inline vector__uint32_t_(const vector__uint32_t_& _s)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_s) {}

      inline vector__uint32_t_(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max) {}
      inline vector__uint32_t_(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULong* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline vector__uint32_t_& operator = (const vector__uint32_t_& _s) {
        _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class vector__uint32_t__out;

    class vector__uint32_t__var {
    public:
      inline vector__uint32_t__var() : _pd_seq(0) {}
      inline vector__uint32_t__var(vector__uint32_t_* _s) : _pd_seq(_s) {}
      inline vector__uint32_t__var(const vector__uint32_t__var& _s) {
        if (_s._pd_seq)  _pd_seq = new vector__uint32_t_(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~vector__uint32_t__var() { if (_pd_seq)  delete _pd_seq; }
        
      inline vector__uint32_t__var& operator = (vector__uint32_t_* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline vector__uint32_t__var& operator = (const vector__uint32_t__var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new vector__uint32_t_;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ::CORBA::ULong& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline vector__uint32_t_* operator -> () { return _pd_seq; }
      inline const vector__uint32_t_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator vector__uint32_t_& () const { return *_pd_seq; }
#else
      inline operator const vector__uint32_t_& () const { return *_pd_seq; }
      inline operator vector__uint32_t_& () { return *_pd_seq; }
#endif
        
      inline const vector__uint32_t_& in() const { return *_pd_seq; }
      inline vector__uint32_t_&       inout()    { return *_pd_seq; }
      inline vector__uint32_t_*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline vector__uint32_t_* _retn() { vector__uint32_t_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class vector__uint32_t__out;
      
    private:
      vector__uint32_t_* _pd_seq;
    };

    class vector__uint32_t__out {
    public:
      inline vector__uint32_t__out(vector__uint32_t_*& _s) : _data(_s) { _data = 0; }
      inline vector__uint32_t__out(vector__uint32_t__var& _s)
        : _data(_s._pd_seq) { _s = (vector__uint32_t_*) 0; }
      inline vector__uint32_t__out(const vector__uint32_t__out& _s) : _data(_s._data) {}
      inline vector__uint32_t__out& operator = (const vector__uint32_t__out& _s) {
        _data = _s._data;
        return *this;
      }
      inline vector__uint32_t__out& operator = (vector__uint32_t_* _s) {
        _data = _s;
        return *this;
      }
      inline operator vector__uint32_t_*&()  { return _data; }
      inline vector__uint32_t_*& ptr()       { return _data; }
      inline vector__uint32_t_* operator->() { return _data; }

      inline ::CORBA::ULong& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      vector__uint32_t_*& _data;

    private:
      vector__uint32_t__out();
      vector__uint32_t__out& operator=(const vector__uint32_t__var&);
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__uint8_t_;

    class vector__uint8_t__var;

    class vector__uint8_t_ : public _CORBA_Unbounded_Sequence_Octet {
    public:
      typedef vector__uint8_t__var _var_type;
      inline vector__uint8_t_() {}
      inline vector__uint8_t_(const vector__uint8_t_& _s)
        : _CORBA_Unbounded_Sequence_Octet(_s) {}

      inline vector__uint8_t_(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Octet(_max) {}
      inline vector__uint8_t_(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

    

      inline vector__uint8_t_& operator = (const vector__uint8_t_& _s) {
        _CORBA_Unbounded_Sequence_Octet::operator=(_s);
        return *this;
      }
    };

    class vector__uint8_t__out;

    class vector__uint8_t__var {
    public:
      inline vector__uint8_t__var() : _pd_seq(0) {}
      inline vector__uint8_t__var(vector__uint8_t_* _s) : _pd_seq(_s) {}
      inline vector__uint8_t__var(const vector__uint8_t__var& _s) {
        if (_s._pd_seq)  _pd_seq = new vector__uint8_t_(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~vector__uint8_t__var() { if (_pd_seq)  delete _pd_seq; }
        
      inline vector__uint8_t__var& operator = (vector__uint8_t_* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline vector__uint8_t__var& operator = (const vector__uint8_t__var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new vector__uint8_t_;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline vector__uint8_t_* operator -> () { return _pd_seq; }
      inline const vector__uint8_t_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator vector__uint8_t_& () const { return *_pd_seq; }
#else
      inline operator const vector__uint8_t_& () const { return *_pd_seq; }
      inline operator vector__uint8_t_& () { return *_pd_seq; }
#endif
        
      inline const vector__uint8_t_& in() const { return *_pd_seq; }
      inline vector__uint8_t_&       inout()    { return *_pd_seq; }
      inline vector__uint8_t_*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline vector__uint8_t_* _retn() { vector__uint8_t_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class vector__uint8_t__out;
      
    private:
      vector__uint8_t_* _pd_seq;
    };

    class vector__uint8_t__out {
    public:
      inline vector__uint8_t__out(vector__uint8_t_*& _s) : _data(_s) { _data = 0; }
      inline vector__uint8_t__out(vector__uint8_t__var& _s)
        : _data(_s._pd_seq) { _s = (vector__uint8_t_*) 0; }
      inline vector__uint8_t__out(const vector__uint8_t__out& _s) : _data(_s._data) {}
      inline vector__uint8_t__out& operator = (const vector__uint8_t__out& _s) {
        _data = _s._data;
        return *this;
      }
      inline vector__uint8_t__out& operator = (vector__uint8_t_* _s) {
        _data = _s;
        return *this;
      }
      inline operator vector__uint8_t_*&()  { return _data; }
      inline vector__uint8_t_*& ptr()       { return _data; }
      inline vector__uint8_t_* operator->() { return _data; }

      inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      vector__uint8_t_*& _data;

    private:
      vector__uint8_t__out();
      vector__uint8_t__out& operator=(const vector__uint8_t__var&);
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__std_string_;

    class vector__std_string__var;

    class vector__std_string_ : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef vector__std_string__var _var_type;
      inline vector__std_string_() {}
      inline vector__std_string_(const vector__std_string_& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline vector__std_string_(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline vector__std_string_(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline vector__std_string_& operator = (const vector__std_string_& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class vector__std_string__out;

    class vector__std_string__var {
    public:
      inline vector__std_string__var() : _pd_seq(0) {}
      inline vector__std_string__var(vector__std_string_* _s) : _pd_seq(_s) {}
      inline vector__std_string__var(const vector__std_string__var& _s) {
        if (_s._pd_seq)  _pd_seq = new vector__std_string_(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~vector__std_string__var() { if (_pd_seq)  delete _pd_seq; }
        
      inline vector__std_string__var& operator = (vector__std_string_* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline vector__std_string__var& operator = (const vector__std_string__var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new vector__std_string_;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline vector__std_string_* operator -> () { return _pd_seq; }
      inline const vector__std_string_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator vector__std_string_& () const { return *_pd_seq; }
#else
      inline operator const vector__std_string_& () const { return *_pd_seq; }
      inline operator vector__std_string_& () { return *_pd_seq; }
#endif
        
      inline const vector__std_string_& in() const { return *_pd_seq; }
      inline vector__std_string_&       inout()    { return *_pd_seq; }
      inline vector__std_string_*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline vector__std_string_* _retn() { vector__std_string_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class vector__std_string__out;
      
    private:
      vector__std_string_* _pd_seq;
    };

    class vector__std_string__out {
    public:
      inline vector__std_string__out(vector__std_string_*& _s) : _data(_s) { _data = 0; }
      inline vector__std_string__out(vector__std_string__var& _s)
        : _data(_s._pd_seq) { _s = (vector__std_string_*) 0; }
      inline vector__std_string__out(const vector__std_string__out& _s) : _data(_s._data) {}
      inline vector__std_string__out& operator = (const vector__std_string__out& _s) {
        _data = _s._data;
        return *this;
      }
      inline vector__std_string__out& operator = (vector__std_string_* _s) {
        _data = _s;
        return *this;
      }
      inline operator vector__std_string_*&()  { return _data; }
      inline vector__std_string_*& ptr()       { return _data; }
      inline vector__std_string_* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      vector__std_string_*& _data;

    private:
      vector__std_string__out();
      vector__std_string__out& operator=(const vector__std_string__var&);
    };

  _CORBA_MODULE_END

  _CORBA_MODULE base

  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__std_vector__base_JointState__;

      class vector__std_vector__base_JointState___var;

      class vector__std_vector__base_JointState__ : public _CORBA_Unbounded_Sequence< vector__base_JointState_ >  {
      public:
        typedef vector__std_vector__base_JointState___var _var_type;
        inline vector__std_vector__base_JointState__() {}
        inline vector__std_vector__base_JointState__(const vector__std_vector__base_JointState__& _s)
          : _CORBA_Unbounded_Sequence< vector__base_JointState_ > (_s) {}

        inline vector__std_vector__base_JointState__(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< vector__base_JointState_ > (_max) {}
        inline vector__std_vector__base_JointState__(_CORBA_ULong _max, _CORBA_ULong _len, vector__base_JointState_* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< vector__base_JointState_ > (_max, _len, _val, _rel) {}

      

        inline vector__std_vector__base_JointState__& operator = (const vector__std_vector__base_JointState__& _s) {
          _CORBA_Unbounded_Sequence< vector__base_JointState_ > ::operator=(_s);
          return *this;
        }
      };

      class vector__std_vector__base_JointState___out;

      class vector__std_vector__base_JointState___var {
      public:
        inline vector__std_vector__base_JointState___var() : _pd_seq(0) {}
        inline vector__std_vector__base_JointState___var(vector__std_vector__base_JointState__* _s) : _pd_seq(_s) {}
        inline vector__std_vector__base_JointState___var(const vector__std_vector__base_JointState___var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__std_vector__base_JointState__(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__std_vector__base_JointState___var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__std_vector__base_JointState___var& operator = (vector__std_vector__base_JointState__* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__std_vector__base_JointState___var& operator = (const vector__std_vector__base_JointState___var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__std_vector__base_JointState__;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline vector__base_JointState_& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__std_vector__base_JointState__* operator -> () { return _pd_seq; }
        inline const vector__std_vector__base_JointState__* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__std_vector__base_JointState__& () const { return *_pd_seq; }
#else
        inline operator const vector__std_vector__base_JointState__& () const { return *_pd_seq; }
        inline operator vector__std_vector__base_JointState__& () { return *_pd_seq; }
#endif
          
        inline const vector__std_vector__base_JointState__& in() const { return *_pd_seq; }
        inline vector__std_vector__base_JointState__&       inout()    { return *_pd_seq; }
        inline vector__std_vector__base_JointState__*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__std_vector__base_JointState__* _retn() { vector__std_vector__base_JointState__* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__std_vector__base_JointState___out;
        
      private:
        vector__std_vector__base_JointState__* _pd_seq;
      };

      class vector__std_vector__base_JointState___out {
      public:
        inline vector__std_vector__base_JointState___out(vector__std_vector__base_JointState__*& _s) : _data(_s) { _data = 0; }
        inline vector__std_vector__base_JointState___out(vector__std_vector__base_JointState___var& _s)
          : _data(_s._pd_seq) { _s = (vector__std_vector__base_JointState__*) 0; }
        inline vector__std_vector__base_JointState___out(const vector__std_vector__base_JointState___out& _s) : _data(_s._data) {}
        inline vector__std_vector__base_JointState___out& operator = (const vector__std_vector__base_JointState___out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__std_vector__base_JointState___out& operator = (vector__std_vector__base_JointState__* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__std_vector__base_JointState__*&()  { return _data; }
        inline vector__std_vector__base_JointState__*& ptr()       { return _data; }
        inline vector__std_vector__base_JointState__* operator->() { return _data; }

        inline vector__base_JointState_& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__std_vector__base_JointState__*& _data;

      private:
        vector__std_vector__base_JointState___out();
        vector__std_vector__base_JointState___out& operator=(const vector__std_vector__base_JointState___var&);
      };

      struct JointLimits {
        typedef _CORBA_ConstrType_Variable_Var<JointLimits> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__base_JointLimitRange_ elements;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef JointLimits::_var_type JointLimits_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< JointLimits,JointLimits_var > JointLimits_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_JointLimits;

      struct JointsTrajectory {
        typedef _CORBA_ConstrType_Variable_Var<JointsTrajectory> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__std_vector__base_JointState__ elements;

        vector__base_Time_ times;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef JointsTrajectory::_var_type JointsTrajectory_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< JointsTrajectory,JointsTrajectory_var > JointsTrajectory_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_JointsTrajectory;

      struct NamedVector__base_JointLimitRange_ {
        typedef _CORBA_ConstrType_Variable_Var<NamedVector__base_JointLimitRange_> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__base_JointLimitRange_ elements;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef NamedVector__base_JointLimitRange_::_var_type NamedVector__base_JointLimitRange__var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< NamedVector__base_JointLimitRange_,NamedVector__base_JointLimitRange__var > NamedVector__base_JointLimitRange__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NamedVector__base_JointLimitRange_;

      struct NamedVector__base_JointState_ {
        typedef _CORBA_ConstrType_Variable_Var<NamedVector__base_JointState_> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__base_JointState_ elements;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef NamedVector__base_JointState_::_var_type NamedVector__base_JointState__var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< NamedVector__base_JointState_,NamedVector__base_JointState__var > NamedVector__base_JointState__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NamedVector__base_JointState_;

      struct NamedVector__std_vector__base_JointState__ {
        typedef _CORBA_ConstrType_Variable_Var<NamedVector__std_vector__base_JointState__> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__std_vector__base_JointState__ elements;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef NamedVector__std_vector__base_JointState__::_var_type NamedVector__std_vector__base_JointState___var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< NamedVector__std_vector__base_JointState__,NamedVector__std_vector__base_JointState___var > NamedVector__std_vector__base_JointState___out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NamedVector__std_vector__base_JointState__;

    _CORBA_MODULE_END

    _CORBA_MODULE samples

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        struct DepthMap {
          typedef _CORBA_ConstrType_Variable_Var<DepthMap> _var_type;

          
          base::Corba::Time time;

          base::Corba::vector__base_Time_ timestamps;

          samples::DepthMap::Corba::PROJECTION_TYPE vertical_projection;

          samples::DepthMap::Corba::PROJECTION_TYPE horizontal_projection;

          orogen::Corba::vector__double_ vertical_interval;

          orogen::Corba::vector__double_ horizontal_interval;

          ::CORBA::ULong vertical_size;

          ::CORBA::ULong horizontal_size;

          orogen::Corba::vector__float_ distances;

          orogen::Corba::vector__float_ remissions;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef DepthMap::_var_type DepthMap_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< DepthMap,DepthMap_var > DepthMap_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DepthMap;

        struct DistanceImage {
          typedef _CORBA_ConstrType_Variable_Var<DistanceImage> _var_type;

          
          base::Corba::Time time;

          ::CORBA::UShort width;

          ::CORBA::UShort height;

          ::CORBA::Float scale_x;

          ::CORBA::Float scale_y;

          ::CORBA::Float center_x;

          ::CORBA::Float center_y;

          orogen::Corba::vector__float_ data;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef DistanceImage::_var_type DistanceImage_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< DistanceImage,DistanceImage_var > DistanceImage_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DistanceImage;

        struct Joints {
          typedef _CORBA_ConstrType_Variable_Var<Joints> _var_type;

          
          orogen::Corba::vector__std_string_ names;

          base::Corba::vector__base_JointState_ elements;

          base::Corba::Time time;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Joints::_var_type Joints_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< Joints,Joints_var > Joints_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Joints;

        struct LaserScan {
          typedef _CORBA_ConstrType_Variable_Var<LaserScan> _var_type;

          
          base::Corba::Time time;

          ::CORBA::Double start_angle;

          ::CORBA::Double angular_resolution;

          ::CORBA::Double speed;

          orogen::Corba::vector__uint32_t_ ranges;

          ::CORBA::ULong minRange;

          ::CORBA::ULong maxRange;

          orogen::Corba::vector__float_ remission;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef LaserScan::_var_type LaserScan_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< LaserScan,LaserScan_var > LaserScan_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LaserScan;

        struct Sonar {
          typedef _CORBA_ConstrType_Variable_Var<Sonar> _var_type;

          
          base::Corba::Time time;

          base::Corba::vector__base_Time_ timestamps;

          base::Corba::Time bin_duration;

          base::Corba::Angle beam_width;

          base::Corba::Angle beam_height;

          base::Corba::vector__base_Angle_ bearings;

          ::CORBA::Float speed_of_sound;

          ::CORBA::ULong bin_count;

          ::CORBA::ULong beam_count;

          orogen::Corba::vector__float_ bins;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Sonar::_var_type Sonar_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< Sonar,Sonar_var > Sonar_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Sonar;

        struct SonarBeam {
          typedef _CORBA_ConstrType_Variable_Var<SonarBeam> _var_type;

          
          base::Corba::Time time;

          base::Corba::Angle bearing;

          ::CORBA::Double sampling_interval;

          ::CORBA::Float speed_of_sound;

          ::CORBA::Float beamwidth_horizontal;

          ::CORBA::Float beamwidth_vertical;

          orogen::Corba::vector__uint8_t_ beam;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef SonarBeam::_var_type SonarBeam_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< SonarBeam,SonarBeam_var > SonarBeam_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SonarBeam;

        struct SonarScan {
          typedef _CORBA_ConstrType_Variable_Var<SonarScan> _var_type;

          
          base::Corba::Time time;

          orogen::Corba::vector__uint8_t_ data;

          base::Corba::vector__base_Time_ time_beams;

          ::CORBA::UShort number_of_beams;

          ::CORBA::UShort number_of_bins;

          base::Corba::Angle start_bearing;

          base::Corba::Angle angular_resolution;

          ::CORBA::Double sampling_interval;

          ::CORBA::Float speed_of_sound;

          base::Corba::Angle beamwidth_horizontal;

          base::Corba::Angle beamwidth_vertical;

          ::CORBA::Boolean memory_layout_column;

          ::CORBA::Boolean polar_coordinates;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef SonarScan::_var_type SonarScan_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< SonarScan,SonarScan_var > SonarScan_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SonarScan;

      _CORBA_MODULE_END

      _CORBA_MODULE frame

      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba

        _CORBA_MODULE_BEG

          struct frame_attrib_t {
            typedef _CORBA_ConstrType_Variable_Var<frame_attrib_t> _var_type;

            
            ::CORBA::String_member data_;

            ::CORBA::String_member name_;

          

            void operator>>= (cdrStream &) const;
            void operator<<= (cdrStream &);
          };

          typedef frame_attrib_t::_var_type frame_attrib_t_var;

          typedef _CORBA_ConstrType_Variable_OUT_arg< frame_attrib_t,frame_attrib_t_var > frame_attrib_t_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_frame_attrib_t;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_samples_frame_frame_attrib_t_;

          class vector__base_samples_frame_frame_attrib_t__var;

          class vector__base_samples_frame_frame_attrib_t_ : public _CORBA_Unbounded_Sequence< frame_attrib_t >  {
          public:
            typedef vector__base_samples_frame_frame_attrib_t__var _var_type;
            inline vector__base_samples_frame_frame_attrib_t_() {}
            inline vector__base_samples_frame_frame_attrib_t_(const vector__base_samples_frame_frame_attrib_t_& _s)
              : _CORBA_Unbounded_Sequence< frame_attrib_t > (_s) {}

            inline vector__base_samples_frame_frame_attrib_t_(_CORBA_ULong _max)
              : _CORBA_Unbounded_Sequence< frame_attrib_t > (_max) {}
            inline vector__base_samples_frame_frame_attrib_t_(_CORBA_ULong _max, _CORBA_ULong _len, frame_attrib_t* _val, _CORBA_Boolean _rel=0)
              : _CORBA_Unbounded_Sequence< frame_attrib_t > (_max, _len, _val, _rel) {}

          

            inline vector__base_samples_frame_frame_attrib_t_& operator = (const vector__base_samples_frame_frame_attrib_t_& _s) {
              _CORBA_Unbounded_Sequence< frame_attrib_t > ::operator=(_s);
              return *this;
            }
          };

          class vector__base_samples_frame_frame_attrib_t__out;

          class vector__base_samples_frame_frame_attrib_t__var {
          public:
            inline vector__base_samples_frame_frame_attrib_t__var() : _pd_seq(0) {}
            inline vector__base_samples_frame_frame_attrib_t__var(vector__base_samples_frame_frame_attrib_t_* _s) : _pd_seq(_s) {}
            inline vector__base_samples_frame_frame_attrib_t__var(const vector__base_samples_frame_frame_attrib_t__var& _s) {
              if (_s._pd_seq)  _pd_seq = new vector__base_samples_frame_frame_attrib_t_(*_s._pd_seq);
              else             _pd_seq = 0;
            }
            inline ~vector__base_samples_frame_frame_attrib_t__var() { if (_pd_seq)  delete _pd_seq; }
              
            inline vector__base_samples_frame_frame_attrib_t__var& operator = (vector__base_samples_frame_frame_attrib_t_* _s) {
              if (_pd_seq)  delete _pd_seq;
              _pd_seq = _s;
              return *this;
            }
            inline vector__base_samples_frame_frame_attrib_t__var& operator = (const vector__base_samples_frame_frame_attrib_t__var& _s) {
              if (&_s != this) {
                if (_s._pd_seq) {
                  if (!_pd_seq)  _pd_seq = new vector__base_samples_frame_frame_attrib_t_;
                  *_pd_seq = *_s._pd_seq;
                }
                else if (_pd_seq) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
              }
              return *this;
            }
            inline frame_attrib_t& operator [] (_CORBA_ULong _s) {
              return (*_pd_seq)[_s];
            }

          

            inline vector__base_samples_frame_frame_attrib_t_* operator -> () { return _pd_seq; }
            inline const vector__base_samples_frame_frame_attrib_t_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
            inline operator vector__base_samples_frame_frame_attrib_t_& () const { return *_pd_seq; }
#else
            inline operator const vector__base_samples_frame_frame_attrib_t_& () const { return *_pd_seq; }
            inline operator vector__base_samples_frame_frame_attrib_t_& () { return *_pd_seq; }
#endif
              
            inline const vector__base_samples_frame_frame_attrib_t_& in() const { return *_pd_seq; }
            inline vector__base_samples_frame_frame_attrib_t_&       inout()    { return *_pd_seq; }
            inline vector__base_samples_frame_frame_attrib_t_*&      out() {
              if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
              return _pd_seq;
            }
            inline vector__base_samples_frame_frame_attrib_t_* _retn() { vector__base_samples_frame_frame_attrib_t_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
              
            friend class vector__base_samples_frame_frame_attrib_t__out;
            
          private:
            vector__base_samples_frame_frame_attrib_t_* _pd_seq;
          };

          class vector__base_samples_frame_frame_attrib_t__out {
          public:
            inline vector__base_samples_frame_frame_attrib_t__out(vector__base_samples_frame_frame_attrib_t_*& _s) : _data(_s) { _data = 0; }
            inline vector__base_samples_frame_frame_attrib_t__out(vector__base_samples_frame_frame_attrib_t__var& _s)
              : _data(_s._pd_seq) { _s = (vector__base_samples_frame_frame_attrib_t_*) 0; }
            inline vector__base_samples_frame_frame_attrib_t__out(const vector__base_samples_frame_frame_attrib_t__out& _s) : _data(_s._data) {}
            inline vector__base_samples_frame_frame_attrib_t__out& operator = (const vector__base_samples_frame_frame_attrib_t__out& _s) {
              _data = _s._data;
              return *this;
            }
            inline vector__base_samples_frame_frame_attrib_t__out& operator = (vector__base_samples_frame_frame_attrib_t_* _s) {
              _data = _s;
              return *this;
            }
            inline operator vector__base_samples_frame_frame_attrib_t_*&()  { return _data; }
            inline vector__base_samples_frame_frame_attrib_t_*& ptr()       { return _data; }
            inline vector__base_samples_frame_frame_attrib_t_* operator->() { return _data; }

            inline frame_attrib_t& operator [] (_CORBA_ULong _i) {
              return (*_data)[_i];
            }

          

            vector__base_samples_frame_frame_attrib_t_*& _data;

          private:
            vector__base_samples_frame_frame_attrib_t__out();
            vector__base_samples_frame_frame_attrib_t__out& operator=(const vector__base_samples_frame_frame_attrib_t__var&);
          };

          struct Frame {
            typedef _CORBA_ConstrType_Variable_Var<Frame> _var_type;

            
            base::Corba::Time time;

            base::Corba::Time received_time;

            orogen::Corba::vector__uint8_t_ image;

            vector__base_samples_frame_frame_attrib_t_ attributes;

            frame_size_t size;

            ::CORBA::ULong data_depth;

            ::CORBA::ULong pixel_size;

            ::CORBA::ULong row_size;

            frame_mode_t frame_mode;

            frame_status_t frame_status;

          

            void operator>>= (cdrStream &) const;
            void operator<<= (cdrStream &);
          };

          typedef Frame::_var_type Frame_var;

          typedef _CORBA_ConstrType_Variable_OUT_arg< Frame,Frame_var > Frame_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Frame;

          struct FramePair {
            typedef _CORBA_ConstrType_Variable_Var<FramePair> _var_type;

            
            base::Corba::Time time;

            Frame first;

            Frame second;

            ::CORBA::ULong id;

          

            void operator>>= (cdrStream &) const;
            void operator<<= (cdrStream &);
          };

          typedef FramePair::_var_type FramePair_var;

          typedef _CORBA_ConstrType_Variable_OUT_arg< FramePair,FramePair_var > FramePair_out;

          _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FramePair;

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers

  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      struct AngleAxis__double_ {
        typedef _CORBA_ConstrType_Fix_Var<AngleAxis__double_> _var_type;

        
        ::CORBA::Double angle;

        typedef ::CORBA::Double _0RL_axis[3];
        typedef ::CORBA::Double _axis_slice;

        ::CORBA::Double axis[3];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef AngleAxis__double_::_var_type AngleAxis__double__var;

      typedef AngleAxis__double_& AngleAxis__double__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AngleAxis__double_;

      struct Matrix__double_2_1_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_2_1_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[2];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[2];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_2_1_::_var_type Matrix__double_2_1__var;

      typedef Matrix__double_2_1_& Matrix__double_2_1__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_2_1_;

      struct Matrix__double_2_2_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_2_2_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[4];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[4];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_2_2_::_var_type Matrix__double_2_2__var;

      typedef Matrix__double_2_2_& Matrix__double_2_2__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_2_2_;

      struct Matrix__double_3_1_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_3_1_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[3];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[3];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_3_1_::_var_type Matrix__double_3_1__var;

      typedef Matrix__double_3_1_& Matrix__double_3_1__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_3_1_;

      struct Matrix__double_3_3_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_3_3_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[9];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[9];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_3_3_::_var_type Matrix__double_3_3__var;

      typedef Matrix__double_3_3_& Matrix__double_3_3__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_3_3_;

      struct Matrix__double_4_1_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_4_1_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[4];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[4];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_4_1_::_var_type Matrix__double_4_1__var;

      typedef Matrix__double_4_1_& Matrix__double_4_1__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_4_1_;

      struct Matrix__double_4_4_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_4_4_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[16];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[16];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_4_4_::_var_type Matrix__double_4_4__var;

      typedef Matrix__double_4_4_& Matrix__double_4_4__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_4_4_;

      struct Matrix__double_6_1_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_6_1_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[6];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[6];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_6_1_::_var_type Matrix__double_6_1__var;

      typedef Matrix__double_6_1_& Matrix__double_6_1__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_6_1_;

      struct Matrix__double_6_6_ {
        typedef _CORBA_ConstrType_Fix_Var<Matrix__double_6_6_> _var_type;

        
        typedef ::CORBA::Double _0RL_data[36];
        typedef ::CORBA::Double _data_slice;

        ::CORBA::Double data[36];

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Matrix__double_6_6_::_var_type Matrix__double_6_6__var;

      typedef Matrix__double_6_6_& Matrix__double_6_6__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Matrix__double_6_6_;

      struct MatrixX__double_ {
        typedef _CORBA_ConstrType_Variable_Var<MatrixX__double_> _var_type;

        
        ::CORBA::Long rows;

        ::CORBA::Long cols;

        orogen::Corba::vector__double_ data;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef MatrixX__double_::_var_type MatrixX__double__var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< MatrixX__double_,MatrixX__double__var > MatrixX__double__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MatrixX__double_;

      struct Quaternion__double_ {
        typedef _CORBA_ConstrType_Fix_Var<Quaternion__double_> _var_type;

        
        typedef ::CORBA::Double _0RL_im[3];
        typedef ::CORBA::Double _im_slice;

        ::CORBA::Double im[3];

        ::CORBA::Double re;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Quaternion__double_::_var_type Quaternion__double__var;

      typedef Quaternion__double_& Quaternion__double__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Quaternion__double_;

      struct VectorX__double_ {
        typedef _CORBA_ConstrType_Variable_Var<VectorX__double_> _var_type;

        
        orogen::Corba::vector__double_ data;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef VectorX__double_::_var_type VectorX__double__var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< VectorX__double_,VectorX__double__var > VectorX__double__out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_VectorX__double_;

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base

  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      struct JointTransform_m {
        typedef _CORBA_ConstrType_Variable_Var<JointTransform_m> _var_type;

        
        ::CORBA::String_member sourceFrame;

        ::CORBA::String_member targetFrame;

        wrappers::Corba::Matrix__double_3_1_ rotationAxis;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef JointTransform_m::_var_type JointTransform_m_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< JointTransform_m,JointTransform_m_var > JointTransform_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_JointTransform_m;

      struct Pose2D_m {
        typedef _CORBA_ConstrType_Fix_Var<Pose2D_m> _var_type;

        
        wrappers::Corba::Matrix__double_2_1_ position;

        ::CORBA::Double orientation;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Pose2D_m::_var_type Pose2D_m_var;

      typedef Pose2D_m& Pose2D_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Pose2D_m;

      struct Pose_m {
        typedef _CORBA_ConstrType_Fix_Var<Pose_m> _var_type;

        
        wrappers::Corba::Matrix__double_3_1_ position;

        wrappers::Corba::Quaternion__double_ orientation;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Pose_m::_var_type Pose_m_var;

      typedef Pose_m& Pose_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Pose_m;

      struct TransformWithCovariance_m {
        typedef _CORBA_ConstrType_Fix_Var<TransformWithCovariance_m> _var_type;

        
        wrappers::Corba::Matrix__double_3_1_ translation;

        wrappers::Corba::Quaternion__double_ orientation;

        wrappers::Corba::Matrix__double_6_6_ cov;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef TransformWithCovariance_m::_var_type TransformWithCovariance_m_var;

      typedef TransformWithCovariance_m& TransformWithCovariance_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransformWithCovariance_m;

      struct TwistWithCovariance_m {
        typedef _CORBA_ConstrType_Fix_Var<TwistWithCovariance_m> _var_type;

        
        wrappers::Corba::Matrix__double_3_1_ vel;

        wrappers::Corba::Matrix__double_3_1_ rot;

        wrappers::Corba::Matrix__double_6_6_ cov;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef TwistWithCovariance_m::_var_type TwistWithCovariance_m_var;

      typedef TwistWithCovariance_m& TwistWithCovariance_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TwistWithCovariance_m;

      struct Waypoint_m {
        typedef _CORBA_ConstrType_Fix_Var<Waypoint_m> _var_type;

        
        wrappers::Corba::Matrix__double_3_1_ position;

        ::CORBA::Double heading;

        ::CORBA::Double tol_position;

        ::CORBA::Double tol_heading;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Waypoint_m::_var_type Waypoint_m_var;

      typedef Waypoint_m& Waypoint_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Waypoint_m;

      struct Wrench_m {
        typedef _CORBA_ConstrType_Fix_Var<Wrench_m> _var_type;

        
        wrappers::Corba::Matrix__double_3_1_ force;

        wrappers::Corba::Matrix__double_3_1_ torque;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Wrench_m::_var_type Wrench_m_var;

      typedef Wrench_m& Wrench_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Wrench_m;

    _CORBA_MODULE_END

    _CORBA_MODULE commands

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        struct LinearAngular6DCommand_m {
          typedef _CORBA_ConstrType_Fix_Var<LinearAngular6DCommand_m> _var_type;

          
          base::Corba::Time time;

          wrappers::Corba::Matrix__double_3_1_ linear;

          wrappers::Corba::Matrix__double_3_1_ angular;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef LinearAngular6DCommand_m::_var_type LinearAngular6DCommand_m_var;

        typedef LinearAngular6DCommand_m& LinearAngular6DCommand_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LinearAngular6DCommand_m;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        struct BodyState_m {
          typedef _CORBA_ConstrType_Fix_Var<BodyState_m> _var_type;

          
          base::Corba::Time time;

          base::Corba::TransformWithCovariance_m pose;

          base::Corba::TwistWithCovariance_m velocity;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef BodyState_m::_var_type BodyState_m_var;

        typedef BodyState_m& BodyState_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BodyState_m;

        struct IMUSensors_m {
          typedef _CORBA_ConstrType_Fix_Var<IMUSensors_m> _var_type;

          
          base::Corba::Time time;

          wrappers::Corba::Matrix__double_3_1_ acc;

          wrappers::Corba::Matrix__double_3_1_ gyro;

          wrappers::Corba::Matrix__double_3_1_ mag;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef IMUSensors_m::_var_type IMUSensors_m_var;

        typedef IMUSensors_m& IMUSensors_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IMUSensors_m;

        struct PoseWithCovariance_m {
          typedef _CORBA_ConstrType_Variable_Var<PoseWithCovariance_m> _var_type;

          
          base::Corba::Time time;

          ::CORBA::String_member frame_id;

          ::CORBA::String_member object_frame_id;

          base::Corba::TransformWithCovariance_m transform;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef PoseWithCovariance_m::_var_type PoseWithCovariance_m_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< PoseWithCovariance_m,PoseWithCovariance_m_var > PoseWithCovariance_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PoseWithCovariance_m;

        struct RigidBodyAcceleration_m {
          typedef _CORBA_ConstrType_Fix_Var<RigidBodyAcceleration_m> _var_type;

          
          base::Corba::Time time;

          wrappers::Corba::Matrix__double_3_1_ acceleration;

          wrappers::Corba::Matrix__double_3_3_ cov_acceleration;

          wrappers::Corba::Matrix__double_3_1_ angular_acceleration;

          wrappers::Corba::Matrix__double_3_3_ cov_angular_acceleration;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef RigidBodyAcceleration_m::_var_type RigidBodyAcceleration_m_var;

        typedef RigidBodyAcceleration_m& RigidBodyAcceleration_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RigidBodyAcceleration_m;

        struct RigidBodyState_m {
          typedef _CORBA_ConstrType_Variable_Var<RigidBodyState_m> _var_type;

          
          base::Corba::Time time;

          ::CORBA::String_member sourceFrame;

          ::CORBA::String_member targetFrame;

          wrappers::Corba::Matrix__double_3_1_ position;

          wrappers::Corba::Matrix__double_3_3_ cov_position;

          wrappers::Corba::Quaternion__double_ orientation;

          wrappers::Corba::Matrix__double_3_3_ cov_orientation;

          wrappers::Corba::Matrix__double_3_1_ velocity;

          wrappers::Corba::Matrix__double_3_3_ cov_velocity;

          wrappers::Corba::Matrix__double_3_1_ angular_velocity;

          wrappers::Corba::Matrix__double_3_3_ cov_angular_velocity;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef RigidBodyState_m::_var_type RigidBodyState_m_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< RigidBodyState_m,RigidBodyState_m_var > RigidBodyState_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RigidBodyState_m;

        struct Wrench_m {
          typedef _CORBA_ConstrType_Fix_Var<Wrench_m> _var_type;

          
          wrappers::Corba::Matrix__double_3_1_ force;

          wrappers::Corba::Matrix__double_3_1_ torque;

          base::Corba::Time time;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Wrench_m::_var_type Wrench_m_var;

        typedef Wrench_m& Wrench_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Wrench_m;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_JointTransform_m_;

      class vector__base_JointTransform_m__var;

      class vector__base_JointTransform_m_ : public _CORBA_Unbounded_Sequence< JointTransform_m >  {
      public:
        typedef vector__base_JointTransform_m__var _var_type;
        inline vector__base_JointTransform_m_() {}
        inline vector__base_JointTransform_m_(const vector__base_JointTransform_m_& _s)
          : _CORBA_Unbounded_Sequence< JointTransform_m > (_s) {}

        inline vector__base_JointTransform_m_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< JointTransform_m > (_max) {}
        inline vector__base_JointTransform_m_(_CORBA_ULong _max, _CORBA_ULong _len, JointTransform_m* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< JointTransform_m > (_max, _len, _val, _rel) {}

      

        inline vector__base_JointTransform_m_& operator = (const vector__base_JointTransform_m_& _s) {
          _CORBA_Unbounded_Sequence< JointTransform_m > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_JointTransform_m__out;

      class vector__base_JointTransform_m__var {
      public:
        inline vector__base_JointTransform_m__var() : _pd_seq(0) {}
        inline vector__base_JointTransform_m__var(vector__base_JointTransform_m_* _s) : _pd_seq(_s) {}
        inline vector__base_JointTransform_m__var(const vector__base_JointTransform_m__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_JointTransform_m_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_JointTransform_m__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_JointTransform_m__var& operator = (vector__base_JointTransform_m_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_JointTransform_m__var& operator = (const vector__base_JointTransform_m__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_JointTransform_m_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline JointTransform_m& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_JointTransform_m_* operator -> () { return _pd_seq; }
        inline const vector__base_JointTransform_m_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_JointTransform_m_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_JointTransform_m_& () const { return *_pd_seq; }
        inline operator vector__base_JointTransform_m_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_JointTransform_m_& in() const { return *_pd_seq; }
        inline vector__base_JointTransform_m_&       inout()    { return *_pd_seq; }
        inline vector__base_JointTransform_m_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_JointTransform_m_* _retn() { vector__base_JointTransform_m_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_JointTransform_m__out;
        
      private:
        vector__base_JointTransform_m_* _pd_seq;
      };

      class vector__base_JointTransform_m__out {
      public:
        inline vector__base_JointTransform_m__out(vector__base_JointTransform_m_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_JointTransform_m__out(vector__base_JointTransform_m__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_JointTransform_m_*) 0; }
        inline vector__base_JointTransform_m__out(const vector__base_JointTransform_m__out& _s) : _data(_s._data) {}
        inline vector__base_JointTransform_m__out& operator = (const vector__base_JointTransform_m__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_JointTransform_m__out& operator = (vector__base_JointTransform_m_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_JointTransform_m_*&()  { return _data; }
        inline vector__base_JointTransform_m_*& ptr()       { return _data; }
        inline vector__base_JointTransform_m_* operator->() { return _data; }

        inline JointTransform_m& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_JointTransform_m_*& _data;

      private:
        vector__base_JointTransform_m__out();
        vector__base_JointTransform_m__out& operator=(const vector__base_JointTransform_m__var&);
      };

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_Waypoint_m_;

      class vector__base_Waypoint_m__var;

      class vector__base_Waypoint_m_ : public _CORBA_Unbounded_Sequence< Waypoint_m >  {
      public:
        typedef vector__base_Waypoint_m__var _var_type;
        inline vector__base_Waypoint_m_() {}
        inline vector__base_Waypoint_m_(const vector__base_Waypoint_m_& _s)
          : _CORBA_Unbounded_Sequence< Waypoint_m > (_s) {}

        inline vector__base_Waypoint_m_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Waypoint_m > (_max) {}
        inline vector__base_Waypoint_m_(_CORBA_ULong _max, _CORBA_ULong _len, Waypoint_m* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Waypoint_m > (_max, _len, _val, _rel) {}

      

        inline vector__base_Waypoint_m_& operator = (const vector__base_Waypoint_m_& _s) {
          _CORBA_Unbounded_Sequence< Waypoint_m > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_Waypoint_m__out;

      class vector__base_Waypoint_m__var {
      public:
        inline vector__base_Waypoint_m__var() : _pd_seq(0) {}
        inline vector__base_Waypoint_m__var(vector__base_Waypoint_m_* _s) : _pd_seq(_s) {}
        inline vector__base_Waypoint_m__var(const vector__base_Waypoint_m__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_Waypoint_m_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_Waypoint_m__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_Waypoint_m__var& operator = (vector__base_Waypoint_m_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_Waypoint_m__var& operator = (const vector__base_Waypoint_m__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_Waypoint_m_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline Waypoint_m& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_Waypoint_m_* operator -> () { return _pd_seq; }
        inline const vector__base_Waypoint_m_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_Waypoint_m_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_Waypoint_m_& () const { return *_pd_seq; }
        inline operator vector__base_Waypoint_m_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_Waypoint_m_& in() const { return *_pd_seq; }
        inline vector__base_Waypoint_m_&       inout()    { return *_pd_seq; }
        inline vector__base_Waypoint_m_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_Waypoint_m_* _retn() { vector__base_Waypoint_m_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_Waypoint_m__out;
        
      private:
        vector__base_Waypoint_m_* _pd_seq;
      };

      class vector__base_Waypoint_m__out {
      public:
        inline vector__base_Waypoint_m__out(vector__base_Waypoint_m_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_Waypoint_m__out(vector__base_Waypoint_m__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_Waypoint_m_*) 0; }
        inline vector__base_Waypoint_m__out(const vector__base_Waypoint_m__out& _s) : _data(_s._data) {}
        inline vector__base_Waypoint_m__out& operator = (const vector__base_Waypoint_m__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_Waypoint_m__out& operator = (vector__base_Waypoint_m_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_Waypoint_m_*&()  { return _data; }
        inline vector__base_Waypoint_m_*& ptr()       { return _data; }
        inline vector__base_Waypoint_m_* operator->() { return _data; }

        inline Waypoint_m& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_Waypoint_m_*& _data;

      private:
        vector__base_Waypoint_m__out();
        vector__base_Waypoint_m__out& operator=(const vector__base_Waypoint_m__var&);
      };

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_Wrench_m_;

      class vector__base_Wrench_m__var;

      class vector__base_Wrench_m_ : public _CORBA_Unbounded_Sequence< Wrench_m >  {
      public:
        typedef vector__base_Wrench_m__var _var_type;
        inline vector__base_Wrench_m_() {}
        inline vector__base_Wrench_m_(const vector__base_Wrench_m_& _s)
          : _CORBA_Unbounded_Sequence< Wrench_m > (_s) {}

        inline vector__base_Wrench_m_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Wrench_m > (_max) {}
        inline vector__base_Wrench_m_(_CORBA_ULong _max, _CORBA_ULong _len, Wrench_m* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Wrench_m > (_max, _len, _val, _rel) {}

      

        inline vector__base_Wrench_m_& operator = (const vector__base_Wrench_m_& _s) {
          _CORBA_Unbounded_Sequence< Wrench_m > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_Wrench_m__out;

      class vector__base_Wrench_m__var {
      public:
        inline vector__base_Wrench_m__var() : _pd_seq(0) {}
        inline vector__base_Wrench_m__var(vector__base_Wrench_m_* _s) : _pd_seq(_s) {}
        inline vector__base_Wrench_m__var(const vector__base_Wrench_m__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_Wrench_m_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_Wrench_m__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_Wrench_m__var& operator = (vector__base_Wrench_m_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_Wrench_m__var& operator = (const vector__base_Wrench_m__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_Wrench_m_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline Wrench_m& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_Wrench_m_* operator -> () { return _pd_seq; }
        inline const vector__base_Wrench_m_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_Wrench_m_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_Wrench_m_& () const { return *_pd_seq; }
        inline operator vector__base_Wrench_m_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_Wrench_m_& in() const { return *_pd_seq; }
        inline vector__base_Wrench_m_&       inout()    { return *_pd_seq; }
        inline vector__base_Wrench_m_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_Wrench_m_* _retn() { vector__base_Wrench_m_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_Wrench_m__out;
        
      private:
        vector__base_Wrench_m_* _pd_seq;
      };

      class vector__base_Wrench_m__out {
      public:
        inline vector__base_Wrench_m__out(vector__base_Wrench_m_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_Wrench_m__out(vector__base_Wrench_m__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_Wrench_m_*) 0; }
        inline vector__base_Wrench_m__out(const vector__base_Wrench_m__out& _s) : _data(_s._data) {}
        inline vector__base_Wrench_m__out& operator = (const vector__base_Wrench_m__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_Wrench_m__out& operator = (vector__base_Wrench_m_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_Wrench_m_*&()  { return _data; }
        inline vector__base_Wrench_m_*& ptr()       { return _data; }
        inline vector__base_Wrench_m_* operator->() { return _data; }

        inline Wrench_m& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_Wrench_m_*& _data;

      private:
        vector__base_Wrench_m__out();
        vector__base_Wrench_m__out& operator=(const vector__base_Wrench_m__var&);
      };

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers

  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__wrappers_Matrix__double_3_1__;

      class vector__wrappers_Matrix__double_3_1___var;

      class vector__wrappers_Matrix__double_3_1__ : public _CORBA_Unbounded_Sequence< Matrix__double_3_1_ >  {
      public:
        typedef vector__wrappers_Matrix__double_3_1___var _var_type;
        inline vector__wrappers_Matrix__double_3_1__() {}
        inline vector__wrappers_Matrix__double_3_1__(const vector__wrappers_Matrix__double_3_1__& _s)
          : _CORBA_Unbounded_Sequence< Matrix__double_3_1_ > (_s) {}

        inline vector__wrappers_Matrix__double_3_1__(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Matrix__double_3_1_ > (_max) {}
        inline vector__wrappers_Matrix__double_3_1__(_CORBA_ULong _max, _CORBA_ULong _len, Matrix__double_3_1_* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Matrix__double_3_1_ > (_max, _len, _val, _rel) {}

      

        inline vector__wrappers_Matrix__double_3_1__& operator = (const vector__wrappers_Matrix__double_3_1__& _s) {
          _CORBA_Unbounded_Sequence< Matrix__double_3_1_ > ::operator=(_s);
          return *this;
        }
      };

      class vector__wrappers_Matrix__double_3_1___out;

      class vector__wrappers_Matrix__double_3_1___var {
      public:
        inline vector__wrappers_Matrix__double_3_1___var() : _pd_seq(0) {}
        inline vector__wrappers_Matrix__double_3_1___var(vector__wrappers_Matrix__double_3_1__* _s) : _pd_seq(_s) {}
        inline vector__wrappers_Matrix__double_3_1___var(const vector__wrappers_Matrix__double_3_1___var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__wrappers_Matrix__double_3_1__(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__wrappers_Matrix__double_3_1___var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__wrappers_Matrix__double_3_1___var& operator = (vector__wrappers_Matrix__double_3_1__* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__wrappers_Matrix__double_3_1___var& operator = (const vector__wrappers_Matrix__double_3_1___var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__wrappers_Matrix__double_3_1__;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline Matrix__double_3_1_& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__wrappers_Matrix__double_3_1__* operator -> () { return _pd_seq; }
        inline const vector__wrappers_Matrix__double_3_1__* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__wrappers_Matrix__double_3_1__& () const { return *_pd_seq; }
#else
        inline operator const vector__wrappers_Matrix__double_3_1__& () const { return *_pd_seq; }
        inline operator vector__wrappers_Matrix__double_3_1__& () { return *_pd_seq; }
#endif
          
        inline const vector__wrappers_Matrix__double_3_1__& in() const { return *_pd_seq; }
        inline vector__wrappers_Matrix__double_3_1__&       inout()    { return *_pd_seq; }
        inline vector__wrappers_Matrix__double_3_1__*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__wrappers_Matrix__double_3_1__* _retn() { vector__wrappers_Matrix__double_3_1__* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__wrappers_Matrix__double_3_1___out;
        
      private:
        vector__wrappers_Matrix__double_3_1__* _pd_seq;
      };

      class vector__wrappers_Matrix__double_3_1___out {
      public:
        inline vector__wrappers_Matrix__double_3_1___out(vector__wrappers_Matrix__double_3_1__*& _s) : _data(_s) { _data = 0; }
        inline vector__wrappers_Matrix__double_3_1___out(vector__wrappers_Matrix__double_3_1___var& _s)
          : _data(_s._pd_seq) { _s = (vector__wrappers_Matrix__double_3_1__*) 0; }
        inline vector__wrappers_Matrix__double_3_1___out(const vector__wrappers_Matrix__double_3_1___out& _s) : _data(_s._data) {}
        inline vector__wrappers_Matrix__double_3_1___out& operator = (const vector__wrappers_Matrix__double_3_1___out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__wrappers_Matrix__double_3_1___out& operator = (vector__wrappers_Matrix__double_3_1__* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__wrappers_Matrix__double_3_1__*&()  { return _data; }
        inline vector__wrappers_Matrix__double_3_1__*& ptr()       { return _data; }
        inline vector__wrappers_Matrix__double_3_1__* operator->() { return _data; }

        inline Matrix__double_3_1_& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__wrappers_Matrix__double_3_1__*& _data;

      private:
        vector__wrappers_Matrix__double_3_1___out();
        vector__wrappers_Matrix__double_3_1___out& operator=(const vector__wrappers_Matrix__double_3_1___var&);
      };

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__wrappers_Matrix__double_4_1__;

      class vector__wrappers_Matrix__double_4_1___var;

      class vector__wrappers_Matrix__double_4_1__ : public _CORBA_Unbounded_Sequence< Matrix__double_4_1_ >  {
      public:
        typedef vector__wrappers_Matrix__double_4_1___var _var_type;
        inline vector__wrappers_Matrix__double_4_1__() {}
        inline vector__wrappers_Matrix__double_4_1__(const vector__wrappers_Matrix__double_4_1__& _s)
          : _CORBA_Unbounded_Sequence< Matrix__double_4_1_ > (_s) {}

        inline vector__wrappers_Matrix__double_4_1__(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Matrix__double_4_1_ > (_max) {}
        inline vector__wrappers_Matrix__double_4_1__(_CORBA_ULong _max, _CORBA_ULong _len, Matrix__double_4_1_* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Matrix__double_4_1_ > (_max, _len, _val, _rel) {}

      

        inline vector__wrappers_Matrix__double_4_1__& operator = (const vector__wrappers_Matrix__double_4_1__& _s) {
          _CORBA_Unbounded_Sequence< Matrix__double_4_1_ > ::operator=(_s);
          return *this;
        }
      };

      class vector__wrappers_Matrix__double_4_1___out;

      class vector__wrappers_Matrix__double_4_1___var {
      public:
        inline vector__wrappers_Matrix__double_4_1___var() : _pd_seq(0) {}
        inline vector__wrappers_Matrix__double_4_1___var(vector__wrappers_Matrix__double_4_1__* _s) : _pd_seq(_s) {}
        inline vector__wrappers_Matrix__double_4_1___var(const vector__wrappers_Matrix__double_4_1___var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__wrappers_Matrix__double_4_1__(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__wrappers_Matrix__double_4_1___var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__wrappers_Matrix__double_4_1___var& operator = (vector__wrappers_Matrix__double_4_1__* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__wrappers_Matrix__double_4_1___var& operator = (const vector__wrappers_Matrix__double_4_1___var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__wrappers_Matrix__double_4_1__;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline Matrix__double_4_1_& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__wrappers_Matrix__double_4_1__* operator -> () { return _pd_seq; }
        inline const vector__wrappers_Matrix__double_4_1__* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__wrappers_Matrix__double_4_1__& () const { return *_pd_seq; }
#else
        inline operator const vector__wrappers_Matrix__double_4_1__& () const { return *_pd_seq; }
        inline operator vector__wrappers_Matrix__double_4_1__& () { return *_pd_seq; }
#endif
          
        inline const vector__wrappers_Matrix__double_4_1__& in() const { return *_pd_seq; }
        inline vector__wrappers_Matrix__double_4_1__&       inout()    { return *_pd_seq; }
        inline vector__wrappers_Matrix__double_4_1__*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__wrappers_Matrix__double_4_1__* _retn() { vector__wrappers_Matrix__double_4_1__* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__wrappers_Matrix__double_4_1___out;
        
      private:
        vector__wrappers_Matrix__double_4_1__* _pd_seq;
      };

      class vector__wrappers_Matrix__double_4_1___out {
      public:
        inline vector__wrappers_Matrix__double_4_1___out(vector__wrappers_Matrix__double_4_1__*& _s) : _data(_s) { _data = 0; }
        inline vector__wrappers_Matrix__double_4_1___out(vector__wrappers_Matrix__double_4_1___var& _s)
          : _data(_s._pd_seq) { _s = (vector__wrappers_Matrix__double_4_1__*) 0; }
        inline vector__wrappers_Matrix__double_4_1___out(const vector__wrappers_Matrix__double_4_1___out& _s) : _data(_s._data) {}
        inline vector__wrappers_Matrix__double_4_1___out& operator = (const vector__wrappers_Matrix__double_4_1___out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__wrappers_Matrix__double_4_1___out& operator = (vector__wrappers_Matrix__double_4_1__* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__wrappers_Matrix__double_4_1__*&()  { return _data; }
        inline vector__wrappers_Matrix__double_4_1__*& ptr()       { return _data; }
        inline vector__wrappers_Matrix__double_4_1__* operator->() { return _data; }

        inline Matrix__double_4_1_& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__wrappers_Matrix__double_4_1__*& _data;

      private:
        vector__wrappers_Matrix__double_4_1___out();
        vector__wrappers_Matrix__double_4_1___out& operator=(const vector__wrappers_Matrix__double_4_1___var&);
      };

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base

  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      struct JointTransformVector_m {
        typedef _CORBA_ConstrType_Variable_Var<JointTransformVector_m> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__base_JointTransform_m_ elements;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef JointTransformVector_m::_var_type JointTransformVector_m_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< JointTransformVector_m,JointTransformVector_m_var > JointTransformVector_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_JointTransformVector_m;

      struct NamedVector__base_JointTransform__m {
        typedef _CORBA_ConstrType_Variable_Var<NamedVector__base_JointTransform__m> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__base_JointTransform_m_ elements;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef NamedVector__base_JointTransform__m::_var_type NamedVector__base_JointTransform__m_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< NamedVector__base_JointTransform__m,NamedVector__base_JointTransform__m_var > NamedVector__base_JointTransform__m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NamedVector__base_JointTransform__m;

      struct NamedVector__base_Wrench__m {
        typedef _CORBA_ConstrType_Variable_Var<NamedVector__base_Wrench__m> _var_type;

        
        orogen::Corba::vector__std_string_ names;

        vector__base_Wrench_m_ elements;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef NamedVector__base_Wrench__m::_var_type NamedVector__base_Wrench__m_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< NamedVector__base_Wrench__m,NamedVector__base_Wrench__m_var > NamedVector__base_Wrench__m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NamedVector__base_Wrench__m;

    _CORBA_MODULE_END

    _CORBA_MODULE samples

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        struct Pointcloud_m {
          typedef _CORBA_ConstrType_Variable_Var<Pointcloud_m> _var_type;

          
          base::Corba::Time time;

          wrappers::Corba::vector__wrappers_Matrix__double_3_1__ points;

          wrappers::Corba::vector__wrappers_Matrix__double_4_1__ colors;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Pointcloud_m::_var_type Pointcloud_m_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< Pointcloud_m,Pointcloud_m_var > Pointcloud_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Pointcloud_m;

        struct Wrenches_m {
          typedef _CORBA_ConstrType_Variable_Var<Wrenches_m> _var_type;

          
          orogen::Corba::vector__std_string_ names;

          base::Corba::vector__base_Wrench_m_ elements;

          base::Corba::Time time;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Wrenches_m::_var_type Wrenches_m_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< Wrenches_m,Wrenches_m_var > Wrenches_m_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Wrenches_m;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers

  _CORBA_MODULE_BEG

    _CORBA_MODULE geometry

    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba

      _CORBA_MODULE_BEG

        enum SplineType { DEGENERATE, POLYNOMIAL_BEZIER, POLYNOMIAL_BSPLINE, RATIONAL_BEZIER, RATIONAL_BSPLINE /*, __max_SplineType=0xffffffff */ };
        typedef SplineType& SplineType_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SplineType;

        struct Spline {
          typedef _CORBA_ConstrType_Variable_Var<Spline> _var_type;

          
          ::CORBA::Double geometric_resolution;

          ::CORBA::Long dimension;

          ::CORBA::Long curve_order;

          SplineType kind;

          orogen::Corba::vector__double_ knots;

          orogen::Corba::vector__double_ vertices;

        

          void operator>>= (cdrStream &) const;
          void operator<<= (cdrStream &);
        };

        typedef Spline::_var_type Spline_var;

        typedef _CORBA_ConstrType_Variable_OUT_arg< Spline,Spline_var > Spline_out;

        _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Spline;

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base

  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba

    _CORBA_MODULE_BEG

      struct Trajectory_m {
        typedef _CORBA_ConstrType_Variable_Var<Trajectory_m> _var_type;

        
        ::CORBA::Double speed;

        wrappers::geometry::Corba::Spline spline;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Trajectory_m::_var_type Trajectory_m_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< Trajectory_m,Trajectory_m_var > Trajectory_m_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Trajectory_m;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_vector__base_Trajectory_m_;

      class vector__base_Trajectory_m__var;

      class vector__base_Trajectory_m_ : public _CORBA_Unbounded_Sequence< Trajectory_m >  {
      public:
        typedef vector__base_Trajectory_m__var _var_type;
        inline vector__base_Trajectory_m_() {}
        inline vector__base_Trajectory_m_(const vector__base_Trajectory_m_& _s)
          : _CORBA_Unbounded_Sequence< Trajectory_m > (_s) {}

        inline vector__base_Trajectory_m_(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Trajectory_m > (_max) {}
        inline vector__base_Trajectory_m_(_CORBA_ULong _max, _CORBA_ULong _len, Trajectory_m* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Trajectory_m > (_max, _len, _val, _rel) {}

      

        inline vector__base_Trajectory_m_& operator = (const vector__base_Trajectory_m_& _s) {
          _CORBA_Unbounded_Sequence< Trajectory_m > ::operator=(_s);
          return *this;
        }
      };

      class vector__base_Trajectory_m__out;

      class vector__base_Trajectory_m__var {
      public:
        inline vector__base_Trajectory_m__var() : _pd_seq(0) {}
        inline vector__base_Trajectory_m__var(vector__base_Trajectory_m_* _s) : _pd_seq(_s) {}
        inline vector__base_Trajectory_m__var(const vector__base_Trajectory_m__var& _s) {
          if (_s._pd_seq)  _pd_seq = new vector__base_Trajectory_m_(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~vector__base_Trajectory_m__var() { if (_pd_seq)  delete _pd_seq; }
          
        inline vector__base_Trajectory_m__var& operator = (vector__base_Trajectory_m_* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline vector__base_Trajectory_m__var& operator = (const vector__base_Trajectory_m__var& _s) {
          if (&_s != this) {
            if (_s._pd_seq) {
              if (!_pd_seq)  _pd_seq = new vector__base_Trajectory_m_;
              *_pd_seq = *_s._pd_seq;
            }
            else if (_pd_seq) {
              delete _pd_seq;
              _pd_seq = 0;
            }
          }
          return *this;
        }
        inline Trajectory_m& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline vector__base_Trajectory_m_* operator -> () { return _pd_seq; }
        inline const vector__base_Trajectory_m_* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator vector__base_Trajectory_m_& () const { return *_pd_seq; }
#else
        inline operator const vector__base_Trajectory_m_& () const { return *_pd_seq; }
        inline operator vector__base_Trajectory_m_& () { return *_pd_seq; }
#endif
          
        inline const vector__base_Trajectory_m_& in() const { return *_pd_seq; }
        inline vector__base_Trajectory_m_&       inout()    { return *_pd_seq; }
        inline vector__base_Trajectory_m_*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline vector__base_Trajectory_m_* _retn() { vector__base_Trajectory_m_* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class vector__base_Trajectory_m__out;
        
      private:
        vector__base_Trajectory_m_* _pd_seq;
      };

      class vector__base_Trajectory_m__out {
      public:
        inline vector__base_Trajectory_m__out(vector__base_Trajectory_m_*& _s) : _data(_s) { _data = 0; }
        inline vector__base_Trajectory_m__out(vector__base_Trajectory_m__var& _s)
          : _data(_s._pd_seq) { _s = (vector__base_Trajectory_m_*) 0; }
        inline vector__base_Trajectory_m__out(const vector__base_Trajectory_m__out& _s) : _data(_s._data) {}
        inline vector__base_Trajectory_m__out& operator = (const vector__base_Trajectory_m__out& _s) {
          _data = _s._data;
          return *this;
        }
        inline vector__base_Trajectory_m__out& operator = (vector__base_Trajectory_m_* _s) {
          _data = _s;
          return *this;
        }
        inline operator vector__base_Trajectory_m_*&()  { return _data; }
        inline vector__base_Trajectory_m_*& ptr()       { return _data; }
        inline vector__base_Trajectory_m_* operator->() { return _data; }

        inline Trajectory_m& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        vector__base_Trajectory_m_*& _data;

      private:
        vector__base_Trajectory_m__out();
        vector__base_Trajectory_m__out& operator=(const vector__base_Trajectory_m__var&);
      };

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_orogen
_CORBA_MODULE_BEG

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE JointState
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Time
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE geometry
    _CORBA_MODULE_BEG

      _CORBA_MODULE SplineBase
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE DepthMap
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

      _CORBA_MODULE frame
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE commands
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE Corba
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

      _CORBA_MODULE frame
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE commands
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers
  _CORBA_MODULE_BEG

    _CORBA_MODULE geometry
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_orogen
_CORBA_MODULE_BEG

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE JointState
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Time
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE geometry
    _CORBA_MODULE_BEG

      _CORBA_MODULE SplineBase
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE DepthMap
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

      _CORBA_MODULE frame
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE commands
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE Corba
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

      _CORBA_MODULE frame
      _CORBA_MODULE_BEG

        _CORBA_MODULE Corba
        _CORBA_MODULE_BEG

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE commands
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE samples
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE wrappers
  _CORBA_MODULE_BEG

    _CORBA_MODULE geometry
    _CORBA_MODULE_BEG

      _CORBA_MODULE Corba
      _CORBA_MODULE_BEG

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

  _CORBA_MODULE base
  _CORBA_MODULE_BEG

    _CORBA_MODULE Corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(orogen::base::JointState::Corba::MODE _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::JointState::Corba::MODE& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::JointState::Corba::UNSET) {
    _e = (orogen::base::JointState::Corba::MODE) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::JointState::Corba::MODE _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::JointState::Corba::MODE& _s);

inline void operator >>=(orogen::base::Time::Corba::Resolution _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::Time::Corba::Resolution& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::Time::Corba::Seconds) {
    _e = (orogen::base::Time::Corba::Resolution) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::Time::Corba::Resolution _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Time::Corba::Resolution& _s);

inline void operator >>=(orogen::base::geometry::SplineBase::Corba::CoordinateType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::geometry::SplineBase::Corba::CoordinateType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::geometry::SplineBase::Corba::TANGENT_POINT_FOR_PRIOR) {
    _e = (orogen::base::geometry::SplineBase::Corba::CoordinateType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::geometry::SplineBase::Corba::CoordinateType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::geometry::SplineBase::Corba::CoordinateType& _s);

inline void operator >>=(orogen::base::samples::DepthMap::Corba::DEPTH_MEASUREMENT_STATE _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::samples::DepthMap::Corba::DEPTH_MEASUREMENT_STATE& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::samples::DepthMap::Corba::VALID_MEASUREMENT) {
    _e = (orogen::base::samples::DepthMap::Corba::DEPTH_MEASUREMENT_STATE) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::samples::DepthMap::Corba::DEPTH_MEASUREMENT_STATE _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::DepthMap::Corba::DEPTH_MEASUREMENT_STATE& _s);

inline void operator >>=(orogen::base::samples::DepthMap::Corba::PROJECTION_TYPE _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::samples::DepthMap::Corba::PROJECTION_TYPE& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::samples::DepthMap::Corba::POLAR) {
    _e = (orogen::base::samples::DepthMap::Corba::PROJECTION_TYPE) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::samples::DepthMap::Corba::PROJECTION_TYPE _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::DepthMap::Corba::PROJECTION_TYPE& _s);

inline void operator >>=(orogen::base::samples::DepthMap::Corba::UNIT_AXIS _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::samples::DepthMap::Corba::UNIT_AXIS& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::samples::DepthMap::Corba::UNIT_Z) {
    _e = (orogen::base::samples::DepthMap::Corba::UNIT_AXIS) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::samples::DepthMap::Corba::UNIT_AXIS _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::DepthMap::Corba::UNIT_AXIS& _s);

inline void operator >>=(orogen::base::samples::Corba::LASER_RANGE_ERRORS _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::samples::Corba::LASER_RANGE_ERRORS& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::samples::Corba::TOO_NEAR) {
    _e = (orogen::base::samples::Corba::LASER_RANGE_ERRORS) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::LASER_RANGE_ERRORS _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::LASER_RANGE_ERRORS& _s);

inline void operator >>=(orogen::base::samples::frame::Corba::frame_mode_t _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::samples::frame::Corba::frame_mode_t& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::samples::frame::Corba::RAW_MODES) {
    _e = (orogen::base::samples::frame::Corba::frame_mode_t) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_mode_t _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_mode_t& _s);

inline void operator >>=(orogen::base::samples::frame::Corba::frame_status_t _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::base::samples::frame::Corba::frame_status_t& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::base::samples::frame::Corba::STATUS_VALID) {
    _e = (orogen::base::samples::frame::Corba::frame_status_t) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_status_t _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_status_t& _s);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::frame::Corba::frame_size_t& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_size_t* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_size_t*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::frame::Corba::frame_size_t*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Angle& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Angle* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Angle*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Angle*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::JointState& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::JointState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::JointState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::JointState*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::PoseUpdateThreshold& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::PoseUpdateThreshold* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::PoseUpdateThreshold*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::PoseUpdateThreshold*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Pressure& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Pressure* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Pressure*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Pressure*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Temperature& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Temperature* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Temperature*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Temperature*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Time& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Time* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Time*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Time*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::JointLimitRange& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::JointLimitRange* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::JointLimitRange*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::JointLimitRange*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::TimeStamped__base_commands_Motion2D_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::TimeStamped__base_commands_Motion2D_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::TimeStamped__base_commands_Motion2D_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::TimeStamped__base_commands_Motion2D_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::commands::Corba::Motion2D& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::commands::Corba::Motion2D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::commands::Corba::Motion2D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::commands::Corba::Motion2D*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::commands::Corba::Speed6D& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::commands::Corba::Speed6D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::commands::Corba::Speed6D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::commands::Corba::Speed6D*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Motion2D& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Motion2D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Motion2D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Motion2D*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Pressure& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Pressure* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Pressure*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Pressure*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Temperature& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Temperature* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Temperature*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Temperature*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_Angle_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_Angle_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_Angle_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_Angle_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_JointLimitRange_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_JointLimitRange_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_JointLimitRange_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_JointLimitRange_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_JointState_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_JointState_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_JointState_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_JointState_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_Time_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_Time_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_Time_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_Time_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::Corba::vector__float_& _s);
void operator<<=(::CORBA::Any& _a, orogen::Corba::vector__float_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::Corba::vector__float_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::Corba::vector__float_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::Corba::vector__uint32_t_& _s);
void operator<<=(::CORBA::Any& _a, orogen::Corba::vector__uint32_t_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::Corba::vector__uint32_t_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::Corba::vector__uint32_t_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::Corba::vector__uint8_t_& _s);
void operator<<=(::CORBA::Any& _a, orogen::Corba::vector__uint8_t_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::Corba::vector__uint8_t_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::Corba::vector__uint8_t_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::Corba::vector__std_string_& _s);
void operator<<=(::CORBA::Any& _a, orogen::Corba::vector__std_string_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::Corba::vector__std_string_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::Corba::vector__std_string_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__std_vector__base_JointState__& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__std_vector__base_JointState__* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__std_vector__base_JointState__*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__std_vector__base_JointState__*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::JointLimits& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::JointLimits* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::JointLimits*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::JointLimits*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::JointsTrajectory& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::JointsTrajectory* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::JointsTrajectory*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::JointsTrajectory*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_JointLimitRange_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_JointLimitRange_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_JointLimitRange_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_JointLimitRange_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_JointState_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_JointState_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_JointState_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_JointState_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::NamedVector__std_vector__base_JointState__& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::NamedVector__std_vector__base_JointState__* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::NamedVector__std_vector__base_JointState__*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::NamedVector__std_vector__base_JointState__*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::DepthMap& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::DepthMap* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::DepthMap*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::DepthMap*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::DistanceImage& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::DistanceImage* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::DistanceImage*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::DistanceImage*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Joints& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Joints* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Joints*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Joints*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::LaserScan& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::LaserScan* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::LaserScan*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::LaserScan*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Sonar& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Sonar* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Sonar*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Sonar*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::SonarBeam& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::SonarBeam* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::SonarBeam*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::SonarBeam*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::SonarScan& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::SonarScan* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::SonarScan*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::SonarScan*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::frame::Corba::frame_attrib_t& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_attrib_t* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::frame::Corba::frame_attrib_t*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::frame::Corba::frame_attrib_t*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::samples::frame::Corba::vector__base_samples_frame_frame_attrib_t_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::samples::frame::Corba::vector__base_samples_frame_frame_attrib_t_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::frame::Corba::vector__base_samples_frame_frame_attrib_t_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::frame::Corba::vector__base_samples_frame_frame_attrib_t_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::frame::Corba::Frame& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::frame::Corba::Frame* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::frame::Corba::Frame*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::frame::Corba::Frame*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::frame::Corba::FramePair& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::frame::Corba::FramePair* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::frame::Corba::FramePair*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::frame::Corba::FramePair*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::AngleAxis__double_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::AngleAxis__double_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::AngleAxis__double_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::AngleAxis__double_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_2_1_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_2_1_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_2_1_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_2_1_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_2_2_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_2_2_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_2_2_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_2_2_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_3_1_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_3_1_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_3_1_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_3_1_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_3_3_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_3_3_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_3_3_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_3_3_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_4_1_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_4_1_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_4_1_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_4_1_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_4_4_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_4_4_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_4_4_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_4_4_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_6_1_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_6_1_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_6_1_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_6_1_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_6_6_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_6_6_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Matrix__double_6_6_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Matrix__double_6_6_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::MatrixX__double_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::MatrixX__double_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::MatrixX__double_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::MatrixX__double_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::Quaternion__double_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::Quaternion__double_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::Quaternion__double_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::Quaternion__double_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::VectorX__double_& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::VectorX__double_* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::VectorX__double_*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::VectorX__double_*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::JointTransform_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::JointTransform_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::JointTransform_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::JointTransform_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Pose2D_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Pose2D_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Pose2D_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Pose2D_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Pose_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Pose_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Pose_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Pose_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::TransformWithCovariance_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::TransformWithCovariance_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::TransformWithCovariance_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::TransformWithCovariance_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::TwistWithCovariance_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::TwistWithCovariance_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::TwistWithCovariance_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::TwistWithCovariance_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Waypoint_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Waypoint_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Waypoint_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Waypoint_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Wrench_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Wrench_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Wrench_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Wrench_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::commands::Corba::LinearAngular6DCommand_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::commands::Corba::LinearAngular6DCommand_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::commands::Corba::LinearAngular6DCommand_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::commands::Corba::LinearAngular6DCommand_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::BodyState_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::BodyState_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::BodyState_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::BodyState_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::IMUSensors_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::IMUSensors_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::IMUSensors_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::IMUSensors_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::PoseWithCovariance_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::PoseWithCovariance_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::PoseWithCovariance_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::PoseWithCovariance_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::RigidBodyAcceleration_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::RigidBodyAcceleration_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::RigidBodyAcceleration_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::RigidBodyAcceleration_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::RigidBodyState_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::RigidBodyState_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::RigidBodyState_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::RigidBodyState_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Wrench_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Wrench_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Wrench_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Wrench_m*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_JointTransform_m_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_JointTransform_m_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_JointTransform_m_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_JointTransform_m_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_Waypoint_m_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_Waypoint_m_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_Waypoint_m_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_Waypoint_m_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_Wrench_m_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_Wrench_m_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_Wrench_m_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_Wrench_m_*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::vector__wrappers_Matrix__double_3_1__& _s);
void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::vector__wrappers_Matrix__double_3_1__* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::vector__wrappers_Matrix__double_3_1__*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::vector__wrappers_Matrix__double_3_1__*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::wrappers::Corba::vector__wrappers_Matrix__double_4_1__& _s);
void operator<<=(::CORBA::Any& _a, orogen::wrappers::Corba::vector__wrappers_Matrix__double_4_1__* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::Corba::vector__wrappers_Matrix__double_4_1__*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::Corba::vector__wrappers_Matrix__double_4_1__*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::JointTransformVector_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::JointTransformVector_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::JointTransformVector_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::JointTransformVector_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_JointTransform__m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_JointTransform__m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_JointTransform__m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_JointTransform__m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_Wrench__m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_Wrench__m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::NamedVector__base_Wrench__m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::NamedVector__base_Wrench__m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Pointcloud_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Pointcloud_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Pointcloud_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Pointcloud_m*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::samples::Corba::Wrenches_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::samples::Corba::Wrenches_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::samples::Corba::Wrenches_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::samples::Corba::Wrenches_m*& _sp);

inline void operator >>=(orogen::wrappers::geometry::Corba::SplineType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (orogen::wrappers::geometry::Corba::SplineType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= orogen::wrappers::geometry::Corba::RATIONAL_BSPLINE) {
    _e = (orogen::wrappers::geometry::Corba::SplineType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, orogen::wrappers::geometry::Corba::SplineType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::geometry::Corba::SplineType& _s);

extern void operator<<=(::CORBA::Any& _a, const orogen::wrappers::geometry::Corba::Spline& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::wrappers::geometry::Corba::Spline* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::wrappers::geometry::Corba::Spline*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::wrappers::geometry::Corba::Spline*& _sp);

extern void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::Trajectory_m& _s);
extern void operator<<=(::CORBA::Any& _a, orogen::base::Corba::Trajectory_m* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::Trajectory_m*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::Trajectory_m*& _sp);

void operator<<=(::CORBA::Any& _a, const orogen::base::Corba::vector__base_Trajectory_m_& _s);
void operator<<=(::CORBA::Any& _a, orogen::base::Corba::vector__base_Trajectory_m_* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, orogen::base::Corba::vector__base_Trajectory_m_*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const orogen::base::Corba::vector__base_Trajectory_m_*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_baseTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_baseTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_baseTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_baseTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_baseTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_baseTypes
#endif

#endif  // __baseTypes_hh__

